# -*- coding: utf-8 -*-
"""final_ipl.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vKETVSrr5Mu2rgSP0MH9iPNOMf2tHV5K
"""



from google.colab import drive
drive.mount('/content/drive')

"""# Task
Prepare and inspect the cricket match data by extracting "Project-main.zip", consolidating "teams_info.csv", "Ball_By_Ball_Match_Data.csv", "2024_players_details.csv", and "Match_Info.csv" into the extracted folder, loading all CSVs into pandas DataFrames, and displaying the first few rows and information for each.

## Extract Project-main.zip

### Subtask:
Unzip the `Project-main.zip` file to access its contents. This will create a new directory containing the files from the archive.

**Reasoning**:
To extract the contents of the `Project-main.zip` file, I need to use Python's built-in `zipfile` module. This code block will import the necessary module, define the zip file path and extraction directory, and then proceed to extract all contents.
"""

import zipfile
import os

# Define the path to the zip file
zip_file_path = '/content/Project-main.zip'

# Define the directory where you want to extract the contents
extract_dir = '/content/Project-main'

# Create the extraction directory if it doesn't exist
os.makedirs(extract_dir, exist_ok=True)

# Open the zip file in read mode and extract all its contents
with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall(extract_dir)

print(f"Successfully extracted '{zip_file_path}' to '{extract_dir}'")
print(f"Contents of '{extract_dir}': {os.listdir(extract_dir)}")

"""**Reasoning**:
The previous extraction created a nested directory structure (`/content/Project-main/Project-main`). To ensure the data files are directly accessible in the primary extraction directory (`/content/Project-main`), I will move the contents from the inner 'Project-main' folder to the outer 'Project-main' folder and then remove the now empty inner folder.


"""

import shutil
import os

source_dir = os.path.join(extract_dir, 'Project-main') # This is the nested folder
destination_dir = extract_dir # This is the parent folder

# List contents of the source directory
if os.path.exists(source_dir):
    for item in os.listdir(source_dir):
        s = os.path.join(source_dir, item)
        d = os.path.join(destination_dir, item)
        if os.path.isdir(s):
            shutil.move(s, d)
        else:
            shutil.move(s, d)
    # Remove the empty nested directory after moving its contents
    os.rmdir(source_dir)
    print(f"Moved contents from '{source_dir}' to '{destination_dir}' and removed '{source_dir}'.")
else:
    print(f"Source directory '{source_dir}' does not exist. Assuming contents are already in '{destination_dir}'.")

print(f"Current contents of '{extract_dir}': {os.listdir(extract_dir)}")

"""**Reasoning**:
The main task requires consolidating specific CSV files into the extracted folder. The previous steps extracted `Project-main.zip` into `/content/Project-main`, but the expected data CSVs are not present. The provided file list indicates the CSVs are in `/content/`. Therefore, I need to move these CSV files from the root content directory into the previously created extraction directory (`/content/Project-main`).


"""

import shutil
import os

# List of CSV files to move
csv_files_to_move = [
    'teams_info.csv',
    'Ball_By_Ball_Match_Data.csv',
    '2024_players_details.csv',
    'Match_Info.csv'
]

source_directory = '/content/' # Where the CSVs are currently located
destination_directory = extract_dir # This is '/content/Project-main'

print(f"Moving CSV files to '{destination_directory}'...")

for csv_file in csv_files_to_move:
    source_path = os.path.join(source_directory, csv_file)
    destination_path = os.path.join(destination_directory, csv_file)

    if os.path.exists(source_path):
        shutil.move(source_path, destination_path)
        print(f"Moved '{csv_file}' to '{destination_directory}'")
    else:
        print(f"Warning: '{csv_file}' not found at '{source_path}'")

print(f"\nContents of '{destination_directory}' after moving CSVs: {os.listdir(destination_directory)}")

"""**Reasoning**:
Now that all the necessary CSV files are consolidated in the `/content/Project-main` directory, the next step is to load each of them into pandas DataFrames as required by the main task. After loading, I will display the first few rows and the info for each DataFrame to inspect their structure and content.


"""

import pandas as pd

# Define the directory where the CSV files are now located
data_dir = '/content/Project-main'

# List of CSV files to load
csv_files_to_load = [
    'teams_info.csv',
    'Ball_By_Ball_Match_Data.csv',
    '2024_players_details.csv',
    'Match_Info.csv'
]

# Dictionary to store the dataframes
dataframes = {}

print("Loading CSV files into pandas DataFrames and displaying head and info...")

for csv_file in csv_files_to_load:
    file_path = os.path.join(data_dir, csv_file)
    df_name = csv_file.replace('.csv', '') # Create a clean name for the dataframe

    if os.path.exists(file_path):
        print(f"\n--- Loading {csv_file} ---")
        try:
            df = pd.read_csv(file_path)
            dataframes[df_name] = df
            print(f"Successfully loaded '{csv_file}'. First 5 rows:")
            print(df.head())
            print(f"\nInfo for '{csv_file}':")
            df.info()
        except Exception as e:
            print(f"Error loading '{csv_file}': {e}")
    else:
        print(f"\nWarning: '{csv_file}' not found at '{file_path}'. Skipping.")

print("\nAll specified CSV files processed.")

"""## Final Task

### Subtask:
Provide specific instructions for the 'process and run' part of your request, such as what kind of analysis you'd like to perform or what question you want to answer with this data, after the initial data inspection.

## Summary:

### Data Analysis Key Findings

*   The `Project-main.zip` file was successfully extracted, but it initially created a nested directory structure (`/content/Project-main/Project-main`) and contained project-related files instead of the expected data CSVs.
*   The necessary CSV files (`teams_info.csv`, `Ball_By_Ball_Match_Data.csv`, `2024_players_details.csv`, `Match_Info.csv`) were found in the root `/content/` directory and were subsequently moved into the `/content/Project-main` directory, consolidating all data files.
*   All four CSV files were successfully loaded into pandas DataFrames, and their initial rows and structural information (data types, non-null counts) were displayed, confirming data accessibility.

### Insights or Next Steps

*   The data is now prepared and loaded, enabling further analysis to answer specific questions or perform detailed investigations into the cricket match data.
*   The next step should involve cleaning, transforming, or merging these DataFrames as needed, based on the specific analytical goals for the cricket match data.

# Task
Analyze the cricket match data in the `Match_Info` DataFrame to understand the impact of toss decisions on match outcomes, identify the most successful teams, and determine the top 'player of the match' award winners. Visualize these findings using appropriate charts with legends and provide a summary of the key insights.

## Analyze Toss Impact on Match Outcomes

### Subtask:
Examine the `Match_Info` DataFrame to determine if winning the toss and choosing to bat or field first has a significant impact on the final match result. This will involve grouping by `toss_decision` and `result` and calculating win percentages.

**Reasoning**:
To analyze the impact of toss decision, I will first access the `Match_Info` DataFrame, create a new boolean column `toss_winner_won` to indicate if the toss-winning team also won the match, filter out rows without a clear winner, and then group by `toss_decision` to calculate the win percentage for each decision.
"""

import pandas as pd

# 1. Access the Match_Info DataFrame
match_info_df = dataframes['Match_Info']

# 2. Create a new boolean column 'toss_winner_won'
match_info_df['toss_winner_won'] = (match_info_df['toss_winner'] == match_info_df['winner'])

# 3. Filter out rows where the 'winner' column is null (matches without a decisive outcome)
filtered_match_info_df = match_info_df.dropna(subset=['winner'])

# 4. Group by 'toss_decision' and calculate the mean of 'toss_winner_won'
# This mean represents the win percentage for teams making that toss decision
toss_impact = filtered_match_info_df.groupby('toss_decision')['toss_winner_won'].mean() * 100

# 5. Print the resulting win percentages
print("Impact of Toss Decision on Match Outcome (Win Percentage for Toss Winner):")
print(toss_impact)

"""**Reasoning**:
The previous step calculated the impact of toss decisions on match outcomes. To visualize this data and make it easily interpretable, I will create a bar chart using `toss_impact` data. This visualization will clearly show the difference in win percentages between batting first and fielding first after winning the toss.


"""

import matplotlib.pyplot as plt
import seaborn as sns

# Set a style for the plots
sns.set_style("whitegrid")

# Create a bar chart for toss impact
plt.figure(figsize=(8, 6))
sns.barplot(x=toss_impact.index, y=toss_impact.values, palette='viridis')

plt.title('Impact of Toss Decision on Match Outcome', fontsize=16)
plt.xlabel('Toss Decision', fontsize=12)
plt.ylabel('Win Percentage (%)', fontsize=12)
plt.ylim(0, 100)

# Add exact percentage values on top of the bars
for index, value in enumerate(toss_impact.values):
    plt.text(index, value + 1, f'{value:.2f}%', ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

"""**Reasoning**:
The previous code generated a `FutureWarning` from seaborn regarding the use of `palette` without `hue`. To fix this, I will explicitly set `hue` to `toss_impact.index` and `legend` to `False` in the `sns.barplot` call, as suggested by the warning.


"""

import matplotlib.pyplot as plt
import seaborn as sns

# Set a style for the plots
sns.set_style("whitegrid")

# Create a bar chart for toss impact
plt.figure(figsize=(8, 6))
sns.barplot(x=toss_impact.index, y=toss_impact.values, palette='viridis', hue=toss_impact.index, legend=False)

plt.title('Impact of Toss Decision on Match Outcome', fontsize=16)
plt.xlabel('Toss Decision', fontsize=12)
plt.ylabel('Win Percentage (%)', fontsize=12)
plt.ylim(0, 100)

# Add exact percentage values on top of the bars
for index, value in enumerate(toss_impact.values):
    plt.text(index, value + 1, f'{value:.2f}%', ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

"""## Identify Most Successful Teams

### Subtask:
Calculate the total number of matches won by each team from the `Match_Info` DataFrame and identify the top-performing teams. This will involve analyzing the `winner` column.

**Reasoning**:
To identify the most successful teams, I will count the number of wins for each team from the 'winner' column of the `Match_Info` DataFrame, sort them in descending order, and then display the top 10.
"""

import pandas as pd

# Access the Match_Info DataFrame
match_info_df = dataframes['Match_Info']

# Count the occurrences of each team in the 'winner' column
# This gives the number of matches won by each team
team_wins = match_info_df['winner'].value_counts()

# Display the top 10 most successful teams and their win counts
print("Top 10 Most Successful Teams (by wins):")
print(team_wins.head(10))

# Store team_wins for future visualization if needed
dataframes['team_wins'] = team_wins

"""**Reasoning**:
To visualize the most successful teams, I will create a bar plot using the `team_wins` data, displaying the top 10 teams by their number of wins. This will provide a clear visual representation of team performance.


"""

import matplotlib.pyplot as plt
import seaborn as sns

# Set a style for the plots
sns.set_style("whitegrid")

# Access the team_wins data stored in the dataframes dictionary
team_wins = dataframes['team_wins'].head(10)

plt.figure(figsize=(12, 7))
sns.barplot(x=team_wins.index, y=team_wins.values, palette='crest')

plt.title('Top 10 Most Successful Teams by Wins', fontsize=16)
plt.xlabel('Team Name', fontsize=12)
plt.ylabel('Number of Wins', fontsize=12)
plt.xticks(rotation=45, ha='right') # Rotate team names for better readability

# Add exact win counts on top of the bars
for index, value in enumerate(team_wins.values):
    plt.text(index, value + 1, str(value), ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

"""**Reasoning**:
The previous code generated a `FutureWarning` from seaborn regarding the use of `palette` without `hue`. To fix this, I will explicitly set `hue` to `team_wins.index` and `legend` to `False` in the `sns.barplot` call, as suggested by the warning.


"""

import matplotlib.pyplot as plt
import seaborn as sns

# Set a style for the plots
sns.set_style("whitegrid")

# Access the team_wins data stored in the dataframes dictionary
team_wins = dataframes['team_wins'].head(10)

plt.figure(figsize=(12, 7))
sns.barplot(x=team_wins.index, y=team_wins.values, palette='crest', hue=team_wins.index, legend=False)

plt.title('Top 10 Most Successful Teams by Wins', fontsize=16)
plt.xlabel('Team Name', fontsize=12)
plt.ylabel('Number of Wins', fontsize=12)
plt.xticks(rotation=45, ha='right') # Rotate team names for better readability

# Add exact win counts on top of the bars
for index, value in enumerate(team_wins.values):
    plt.text(index, value + 1, str(value), ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

"""## Determine Top 'Player of the Match' Award Winners

### Subtask:
Identify the players who have won the 'player of the match' award the most times from the `Match_Info` DataFrame. This will involve analyzing the `player_of_match` column.

**Reasoning**:
To identify the top 'player of the match' award winners, I will count the occurrences of each player in the 'player_of_match' column of the `Match_Info` DataFrame, sort them in descending order, and display the top players.
"""

import pandas as pd

# Access the Match_Info DataFrame
match_info_df = dataframes['Match_Info']

# Count the occurrences of each player in the 'player_of_match' column
player_of_match_awards = match_info_df['player_of_match'].value_counts()

# Display the top 10 players with the most 'player of the match' awards
print("Top 10 Players with Most 'Player of the Match' Awards:")
print(player_of_match_awards.head(10))

# Store player_of_match_awards for future visualization if needed
dataframes['player_of_match_awards'] = player_of_match_awards

"""**Reasoning**:
To visualize the top 'player of the match' award winners, I will create a bar plot using the `player_of_match_awards` data, displaying the top 10 players by their number of awards. This will provide a clear visual representation of individual player performance.


"""

import matplotlib.pyplot as plt
import seaborn as sns

# Set a style for the plots
sns.set_style("whitegrid")

# Access the player_of_match_awards data stored in the dataframes dictionary
player_of_match_awards = dataframes['player_of_match_awards'].head(10)

plt.figure(figsize=(12, 7))
sns.barplot(x=player_of_match_awards.index, y=player_of_match_awards.values, palette='plasma', hue=player_of_match_awards.index, legend=False)

plt.title('Top 10 Players with Most "Player of the Match" Awards', fontsize=16);
plt.xlabel('Player Name', fontsize=12);
plt.ylabel('Number of Awards', fontsize=12);
plt.xticks(rotation=45, ha='right'); # Rotate player names for better readability

# Add exact award counts on top of the bars
for index, value in enumerate(player_of_match_awards.values):
    plt.text(index, value + 0.5, str(value), ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

"""## Summary of Key Insights

### Toss Impact on Match Outcomes
*   Winning the toss and choosing to field first appears to offer a slight advantage, with a win percentage of approximately 54.40% for the toss-winning team. This contrasts with choosing to bat first, which results in a win percentage of around 46.21% for the toss-winning team. This suggests that in this dataset, teams generally prefer to chase down a target.

### Most Successful Teams
*   The top 3 most successful teams by number of wins are:
    *   **Mumbai Indians** with 151 wins.
    *   **Chennai Super Kings** with 142 wins.
    *   **Kolkata Knight Riders** with 135 wins.
*   These teams have consistently performed well across the matches in the dataset, indicating their strong presence and historical success in the league.

### Top 'Player of the Match' Award Winners
*   The players who have received the most 'Player of the Match' awards highlight individual brilliance and game-changing performances. The top 3 players are:
    *   **AB de Villiers** with 25 awards.
    *   **CH Gayle** with 22 awards.
    *   **RG Sharma** with 21 awards.
*   These players have repeatedly delivered impactful performances, earning them significant recognition over the years.

## Final Task

### Subtask:
Summarize the key insights gained from the exploratory data analysis on match outcomes, team successes, and individual player performance.

## Summary:

### Q&A

1.  **What is the impact of toss decisions on match outcomes?**
    Teams that win the toss and choose to field first have a statistically higher chance of winning, with approximately 54.40% of toss-winning teams securing a victory when fielding first. Conversely, toss-winning teams choosing to bat first have a lower win percentage of about 46.21%.

2.  **Which are the most successful teams based on total wins?**
    The top three most successful teams by total wins are: Mumbai Indians with 151 wins, Chennai Super Kings with 142 wins, and Kolkata Knight Riders with 135 wins.

3.  **Who are the top 'player of the match' award winners?**
    The top three players with the most 'Player of the Match' awards are: AB de Villiers with 25 awards, CH Gayle with 22 awards, and RG Sharma with 21 awards.

### Data Analysis Key Findings

*   Teams winning the toss and opting to field first had a higher win rate of approximately 54.40%, compared to 46.21% for teams choosing to bat first.
*   The Mumbai Indians are the most successful team with 151 wins, followed by Chennai Super Kings (142 wins) and Kolkata Knight Riders (135 wins).
*   AB de Villiers has received the most 'Player of the Match' awards with 25, followed by CH Gayle (22 awards) and RG Sharma (21 awards).

### Insights or Next Steps

*   **Strategic Advantage**: Teams might consider prioritizing fielding first after winning the toss, especially in conditions that favor chasing, given the observed higher win percentage.
*   **Player Scouting**: The consistent performance of top 'Player of the Match' award winners indicates their significant impact on game outcomes, making them crucial assets for any team.
"""